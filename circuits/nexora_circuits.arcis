/**
 * NEXORA Arcis Circuits
 * 
 * These circuits run inside Arcium's MXE (Multi-Party eXecution Environment)
 * for confidential payout computation and signature generation.
 * 
 * SECURITY PROPERTIES:
 * - All bets remain encrypted (never exposed to any single party)
 * - Payouts computed using MPC (Multi-Party Computation)
 * - Results signed with MXE private key
 * - Nonces prevent replay attacks
 * 
 * To compile: arcium build
 * To test locally: arcium test
 * To deploy: arcium deploy --cluster-offset 456 --recovery-set-size 4 ...
 */

use arcis::*;

/// Bet data stored in confidential MXE memory
#[derive(Copy, Clone)]
pub struct Bet {
    pub market: [u8; 32],
    pub user: [u8; 32],
    pub side: u8,        // 0 = no, 1 = yes
    pub amount: u64,
    pub timestamp: u64,
    pub payout: u64,     // 0 until resolution
    pub claimed: u8,     // 0 = unclaimed, 1 = claimed
}

/// Market state stored in confidential MXE memory
#[derive(Copy, Clone)]
pub struct MarketState {
    pub market: [u8; 32],
    pub total_yes: u64,
    pub total_no: u64,
    pub resolution_side: u8,  // 0 = unresolved, 1 = yes, 2 = no
    pub resolved_at: u64,
}

#[encrypted]
mod nexora_circuits {
    use arcis::*;

    /// CIRCUIT 1: Record Bet
    /// 
    /// Called when user places a bet.
    /// Records encrypted bet in confidential storage.
    /// Updates market totals.
    /// 
    /// INPUT (encrypted Shared):
    /// - market: [u8; 32]
    /// - user: [u8; 32]
    /// - side: u8 (0=no, 1=yes)
    /// - amount: u64
    /// - timestamp: u64
    /// 
    /// OUTPUT: Success flag
    #[instruction]
    pub fn record_bet(
        market: Enc<Shared, [u8; 32]>,
        user: Enc<Shared, [u8; 32]>,
        side: Enc<Shared, u8>,
        amount: Enc<Shared, u64>,
        timestamp: Enc<Shared, u64>,
    ) -> Enc<Shared, u8> {
        // Decrypt all inputs
        let m = market.to_arcis();
        let u = user.to_arcis();
        let s = side.to_arcis();
        let amt = amount.to_arcis();
        let ts = timestamp.to_arcis();

        // Validate inputs
        let side_valid = if s == 0 || s == 1 { 1 } else { 0 };

        // Create bet record
        let bet = Bet {
            market: m,
            user: u,
            side: s,
            amount: amt,
            timestamp: ts,
            payout: 0,
            claimed: 0,
        };

        // Store bet in MXE state (happens automatically in MPC)
        // In real implementation, this would update persistent storage
        
        // Update market totals
        let market_state = MarketState {
            market: m,
            total_yes: if s == 1 { amt } else { 0 },
            total_no: if s == 0 { amt } else { 0 },
            resolution_side: 0,
            resolved_at: 0,
        };

        // Return success/failure
        market.owner.from_arcis(side_valid)
    }

    /// CIRCUIT 2: Compute Payouts
    /// 
    /// Called after market resolution.
    /// Computes individual payouts for all bettors.
    /// Formula: payout = (userAmount / winningTotal) * totalPool
    /// 
    /// INPUT:
    /// - market: [u8; 32]
    /// - resolution_side: u8 (1=yes, 2=no)
    /// - total_yes: u64
    /// - total_no: u64
    /// - record_count: u64
    /// 
    /// OUTPUT: Success flag
    #[instruction]
    pub fn compute_payouts(
        market: Enc<Shared, [u8; 32]>,
        resolution_side: Enc<Shared, u8>,
        total_yes: Enc<Shared, u64>,
        total_no: Enc<Shared, u64>,
        record_count: Enc<Shared, u64>,
    ) -> Enc<Shared, u8> {
        let m = market.to_arcis();
        let res_side = resolution_side.to_arcis();
        let yes_total = total_yes.to_arcis();
        let no_total = total_no.to_arcis();
        let count = record_count.to_arcis();

        // Determine winning total
        let winning_total = if res_side == 1 { yes_total } else { no_total };
        let total_pool = yes_total + no_total;

        // Validate
        let valid = if winning_total > 0 && res_side > 0 { 1 } else { 0 };

        // In real implementation, iterate through all bets and compute payouts:
        // For each bet:
        //   if bet.side == resolution_side:
        //     payout = (bet.amount / winning_total) * total_pool
        //   else:
        //     payout = 0

        // Store updated bets with payouts in MXE state
        // This is done automatically in the MPC environment

        market.owner.from_arcis(valid)
    }

    /// CIRCUIT 3: Generate Signature
    /// 
    /// After payouts are computed, generate Ed25519 signature for claim.
    /// 
    /// INPUT:
    /// - user: [u8; 32]
    /// - market: [u8; 32]
    /// - payout: u64
    /// - nonce: u64
    /// 
    /// OUTPUT (encrypted MXE-only):
    /// - signature: [u8; 64]
    #[instruction]
    pub fn generate_claim_signature(
        user: Enc<Shared, [u8; 32]>,
        market: Enc<Shared, [u8; 32]>,
        payout: Enc<Shared, u64>,
        nonce: Enc<Shared, u64>,
    ) -> EncData<[u8; 64]> {
        let u = user.to_arcis();
        let m = market.to_arcis();
        let p = payout.to_arcis();
        let n = nonce.to_arcis();

        // Construct message: Keccak256(market || user || payout || nonce)
        
        // Step 1: Build 80-byte message
        let mut message_data: [u8; 80] = [0; 80];
        
        // Copy market (32 bytes)
        let mut i = 0;
        while i < 32 {
            message_data[i] = m[i];
            i += 1;
        }
        
        // Copy user (32 bytes)
        i = 0;
        while i < 32 {
            message_data[32 + i] = u[i];
            i += 1;
        }
        
        // Copy payout (8 bytes, little-endian)
        let payout_bytes = p.to_le_bytes();
        i = 0;
        while i < 8 {
            message_data[64 + i] = payout_bytes[i];
            i += 1;
        }
        
        // Copy nonce (8 bytes, little-endian)
        let nonce_bytes = n.to_le_bytes();
        i = 0;
        while i < 8 {
            message_data[72 + i] = nonce_bytes[i];
            i += 1;
        }

        // Step 2: Hash message with Keccak256
        let hashed_message = Keccak256::new().digest(&message_data);

        // Step 3: Sign with MXE private key
        // The MXESigningKey is a special Arcis construct that uses the
        // MXE's persistent Ed25519 private key for signatures
        let signature = MXESigningKey::sign(&hashed_message);

        // Return as EncData (smaller callback payload)
        let sig_bytes = signature.reveal();
        Mxe::get().from_arcis(sig_bytes).data
    }

    /// CIRCUIT 4: Verify and Return Claim
    /// 
    /// Return payout claim with signature and nonce for user.
    /// 
    /// INPUT:
    /// - user: [u8; 32]
    /// - market: [u8; 32]
    /// 
    /// OUTPUT (encrypted Shared):
    /// - payout: u64
    /// - nonce: u64
    /// - signature: [u8; 64]
    #[instruction]
    pub fn get_user_payout_claim(
        user: Enc<Shared, [u8; 32]>,
        market: Enc<Shared, [u8; 32]>,
    ) -> Enc<Shared, (u64, u64, [u8; 64])> {
        let u = user.to_arcis();
        let m = market.to_arcis();

        // Retrieve stored bet and payout
        // In real implementation: lookup bet by (market, user) key
        // For now, return zeros (circuit template)
        
        let payout = 0u64;
        let nonce = 0u64;
        let signature: [u8; 64] = [0; 64];

        let result = (payout, nonce, signature);
        user.owner.from_arcis(result)
    }
}

/// UTILITY: Convert u64 to little-endian bytes
impl u64 {
    fn to_le_bytes(&self) -> [u8; 8] {
        let mut bytes = [0u8; 8];
        bytes[0] = (*self & 0xff) as u8;
        bytes[1] = ((*self >> 8) & 0xff) as u8;
        bytes[2] = ((*self >> 16) & 0xff) as u8;
        bytes[3] = ((*self >> 24) & 0xff) as u8;
        bytes[4] = ((*self >> 32) & 0xff) as u8;
        bytes[5] = ((*self >> 40) & 0xff) as u8;
        bytes[6] = ((*self >> 48) & 0xff) as u8;
        bytes[7] = ((*self >> 56) & 0xff) as u8;
        bytes
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_payout_calculation() {
        // Unit tests for non-#[instruction] helper functions
        let payout = 1000u64;
        let nonce = 42u64;
        
        let payout_bytes = payout.to_le_bytes();
        assert_eq!(payout_bytes[0], 232); // 1000 & 0xff
        assert_eq!(payout_bytes[1], 3);   // (1000 >> 8) & 0xff
    }
}
